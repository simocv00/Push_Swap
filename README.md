# Push_Swap

Push_Swap is a project that challenges you to sort a random list of integers using the smallest number of moves possible, two stacks (a and b), and a limited set of operations.

---

## Table of Contents

- [Challenge](#challenge)
- [The Project](#the-project)
- [Pseudo Code](#pseudo-code)
- [Flow Chart](#flow-chart)
- [Visualizer](#visualizer)
- [Checker](#checker)
- [Resources](#resources)
- [Usage](#usage)
- [Contributing](#contributing)
- [License](#license)

---

## Challenge

Sort a random list of integers using the smallest number of moves, 2 stacks (a and b), and a limited set of operations.

**Rules:**

- You start with two empty stacks: **a** and **b**.
- You are given a random list of integers via command-line arguments.
- Only the following operations are allowed:
  - **sa**: Swap the first 2 elements at the top of stack **a**. Do nothing if there is only one or no elements.
  - **sb**: Swap the first 2 elements at the top of stack **b**. Do nothing if there is only one or no elements.
  - **ss**: Perform both **sa** and **sb** at the same time.
  - **pa**: Push the first element at the top of **b** to the top of **a**. Do nothing if **b** is empty.
  - **pb**: Push the first element at the top of **a** to the top of **b**. Do nothing if **a** is empty.
  - **ra**: Rotate **a** by shifting all elements up by 1. The first element becomes the last one.
  - **rb**: Rotate **b** by shifting all elements up by 1. The first element becomes the last one.
  - **rr**: Perform both **ra** and **rb** at the same time.
  - **rra**: Reverse rotate **a** by shifting all elements down by 1. The last element becomes the first one.
  - **rrb**: Reverse rotate **b** by shifting all elements down by 1. The last element becomes the first one.
  - **rrr**: Perform both **rra** and **rrb** at the same time.

**At the end:**

- Stack **b** must be empty.
- All integers must be in stack **a**, sorted in ascending order.

---

## The Project

This project consists of two programs:

1. **push_swap**  
   - **Purpose:** Calculates the moves required to sort the integers and displays the instructions on stdout.
   - **Note:** The algorithm intentionally leaves the 3 biggest numbers in stack **a** during the main sorting loop to reduce the total number of operations.

2. **checker**  
   - **Purpose:** Reads the list of integers from stdin, applies the instructions provided by **push_swap**, and verifies if the sorting is correct.

**Requirements:**

- Both programs must parse input for errors, including:
  - Empty strings.
  - No parameters.
  - Non-numeric parameters.
  - Duplicates.
  - Invalid or non-existent instructions.
- Must conform to the 42 Norm.
- Allowed libc functions: `write`, `read`, `malloc`, `free`, `exit`.
- No memory leaks.
- Must handle errors carefully without unexpected crashes (segmentation fault, bus error, double free, etc.).

---

## Pseudo Code

**Initialization:**

- Push the first two elements from stack **a** to stack **b**. This creates one smallest and one largest number in stack **b**.

**Sorting Loop:**

- For every number in stack **a**:
  - Compare the number with the smallest and largest numbers in stack **b**.
  - Calculate the minimum number of operations required to place the number in the correct position in stack **b**.
  - Rotate both stack **a** and **b** as needed to minimize the total number of operations.
  - Push the number from stack **a** to stack **b**.

**Final Sorting:**

- Sort the remaining three numbers in stack **a** using basic operations (`sa`, `ra`, `rra`).
- Push all elements from stack **b** back to stack **a** while maintaining their sorted order.
- Apply any final rotations to bring the smallest number to the top of stack **a**.

---

## Flow Chart

For a detailed flowchart of the algorithm, refer to the flowchart image below:  
[Flowchart Image](https://your-image-url.com/flowchart.png)  
*Tip: Open the image in a new tab to zoom in and explore it in detail.*

---

## Visualizer

A visualizer tool is available to graphically represent the sorting process. This can help you understand how the algorithm works step by step.

**To use the visualizer:**

1. Clone the repository containing the visualizer tool.
2. Run the tool and provide the output of **push_swap** as input.

*Include additional usage instructions for your specific visualizer tool if needed.*

---

## Checker

The **checker** program validates the correctness of the sorting process by applying the operations generated by **push_swap** and checking if the stack is sorted.

**Usage Example:**

```bash
./push_swap <arguments> | ./checker <arguments>
